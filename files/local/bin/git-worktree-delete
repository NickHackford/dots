#!/usr/bin/env bash

git_dir=$(git rev-parse --git-common-dir 2>/dev/null) || {
  echo "Not in a git repo"
  exit 1
}

# For worktree structure: my_project/master/, my_project/feature/
# git-common-dir points to my_project/master/.git
# We need to go up two levels: .git -> master -> my_project
# Use realpath to ensure we get absolute paths
git_dir_abs="$(realpath "$git_dir")"
worktree_dir="$(dirname "$git_dir_abs")"
top="$(dirname "$worktree_dir")"

# Check if a branch name was provided as an argument
if [ $# -eq 1 ]; then
  target_branch="$1"
  echo "Looking for worktree with branch: $target_branch"
  
  # Get all worktrees with their branches
  worktree_info=$(git worktree list --porcelain)
  
  # Find the worktree path for the specified branch
  selected_path=""
  selected_branch=""
  
  while IFS= read -r line; do
    if [[ $line == worktree* ]]; then
      current_path="${line#worktree }"
    elif [[ $line == branch* ]]; then
      current_branch="${line#branch }"
      current_branch="${current_branch#refs/heads/}"  # Remove refs/heads/ prefix if present
      
      if [[ "$current_branch" == "$target_branch" ]]; then
        selected_path="$current_path"
        selected_branch="$current_branch"
        break
      fi
    fi
  done <<< "$worktree_info"
  
  if [ -z "$selected_path" ]; then
    echo "Error: No worktree found for branch '$target_branch'"
    exit 1
  fi
else
  # No argument provided, use fzf selection (original behavior)
  # Get all worktrees with their branches
  worktree_info=$(git worktree list --porcelain)

  # Extract and format worktree paths and branches for selection
  formatted_worktrees=$(echo "$worktree_info" |
    awk 'BEGIN {path=""; branch=""} 
    /^worktree / {path=substr($0, 10)} 
    /^branch / {branch=substr($0, 8)} 
    branch != "" && path != "" {print path " [" branch "]"; path=""; branch=""}')

  # Let user select a worktree to delete
  selected=$(echo "$formatted_worktrees" | fzf --height 10 --reverse) || exit 1

  # Extract path and branch from selection
  selected_path=$(echo "$selected" | awk '{print $1}')
  selected_branch=$(echo "$selected" | sed -E 's/.*\[(.*)\].*/\1/' | sed 's/refs\/heads\///')
fi

# Display which worktree and branch will be deleted
echo "Removing worktree at $selected_path"
echo "and deleting branch $selected_branch"

# Kill associated tmux session early in the process
repo_name=$(basename "$top")
formatted_branch=$(echo "$selected_branch" | tr '/' '-')
session_name="${repo_name}_${formatted_branch}"

if tmux has-session -t "$session_name" 2>/dev/null; then
  echo "Killing tmux session: $session_name"
  tmux kill-session -t "$session_name"
fi

current_dir=$PWD

# Make sure we're not in the worktree we're trying to delete
if [[ "$current_dir" == "$selected_path"* ]]; then
  echo "Cannot delete the worktree you're currently in. Moving to the main worktree..."
  cd "$top/master"
fi

# Remove the worktree and delete the branch
git worktree remove --force "$selected_path" &&
  git branch -D "$selected_branch" &&
  echo "Worktree and branch deleted successfully."

# Clean up the directory if it still exists
if [ -d "$selected_path" ]; then
  echo "Removing remaining directory: $selected_path"
  rm -rf "$selected_path"
fi