#!/usr/bin/env bash

# Source helper functions
source "$(dirname "${BASH_SOURCE[0]}")/tmux_helpers"

# Extract file paths with line numbers from tmux scrollback
extract_files_with_lines() {
    tmux capture-pane -J -p | grep -oE "(\./)?[a-zA-Z0-9_/.-]+\.(js|ts|tsx|jsx|py|java|go|rs|cpp|c|h|md|txt|json|yaml|yml|toml|css|scss|html|vue|php|rb|sh|lua|nix) +[0-9]+([:-][0-9]+)*" | \
    sed -E 's/ +([0-9]+).*/:=\1/' | \
    sort | uniq
}

# Extract potential base directories from scrollback output
extract_base_directories() {
    local scrollback="$1"
    # Look for absolute paths in the scrollback that could be base directories
    echo "$scrollback" | grep -oE "/[^[:space:]'\"]+/(static|src|app|lib|test)" | sed 's|/[^/]*$||' | sort | uniq
}

# Resolve relative path to absolute path using multiple strategies
resolve_file_path() {
    local file_path="$1"
    local scrollback="$2"
    local current_dir="$(tmux display-message -p '#{pane_current_path}')"
    
    # Remove leading ./ if present
    file_path="${file_path#./}"
    
    # If already absolute, return as-is
    if [[ "$file_path" = /* ]]; then
        echo "$file_path"
        return
    fi
    
    # Strategy 1: Try current directory first
    if [[ -f "$current_dir/$file_path" ]]; then
        echo "$current_dir/$file_path"
        return
    fi
    
    # Strategy 2: For TypeScript paths starting with "static/", try known project structures
    if [[ "$file_path" =~ ^static/ ]]; then
        # Common HubSpot project patterns
        for project_base in "$current_dir" "$current_dir/.." "$current_dir/../.." "$current_dir/../../.." "/Users/nhackford/src/Social/"*; do
            if [[ -d "$project_base" ]]; then
                test_path="$project_base/$file_path"
                if [[ -f "$test_path" ]]; then
                    echo "$test_path"
                    return
                fi
                # Also try with SocialUI subdirectory
                test_path="$project_base/SocialUI/$file_path"
                if [[ -f "$test_path" ]]; then
                    echo "$test_path"
                    return
                fi
            fi
        done
    fi

    # Strategy 3: Extract base directories from scrollback and try them
    local base_dirs=$(extract_base_directories "$scrollback")
    while IFS= read -r base_dir; do
        if [[ -n "$base_dir" ]]; then
            # Try the base directory directly
            if [[ -f "$base_dir/$file_path" ]]; then
                echo "$base_dir/$file_path"
                return
            fi
            
            # Try common subdirectories within the base
            for subdir in "static" "src" "app" ""; do
                local test_path="$base_dir/$subdir/$file_path"
                if [[ -f "$test_path" ]]; then
                    echo "$test_path"
                    return
                fi
            done
        fi
    done <<< "$base_dirs"
    
    # Strategy 4: Look for project-specific patterns in scrollback
    # Extract full paths that might contain our target file
    local potential_paths=$(echo "$scrollback" | grep -oE "/[^[:space:]'\"]*$file_path" | head -5)
    while IFS= read -r potential_path; do
        if [[ -n "$potential_path" && -f "$potential_path" ]]; then
            echo "$potential_path"
            return
        fi
    done <<< "$potential_paths"
    
    # Strategy 5: Smart search in current directory tree
    local found_file=$(find "$current_dir" -maxdepth 5 -path "*/$file_path" 2>/dev/null | head -1)
    if [[ -n "$found_file" && -f "$found_file" ]]; then
        echo "$found_file"
        return
    fi
    
    # Strategy 6: Search for filename with path context
    local filename=$(basename "$file_path")
    local dirname=$(dirname "$file_path")
    if [[ "$dirname" != "." ]]; then
        found_file=$(find "$current_dir" -maxdepth 5 -path "*/$dirname/$filename" 2>/dev/null | head -1)
        if [[ -n "$found_file" && -f "$found_file" ]]; then
            echo "$found_file"
            return
        fi
    fi
    
    # Strategy 7: Fallback - just the filename
    found_file=$(find "$current_dir" -maxdepth 5 -name "$filename" 2>/dev/null | head -1)
    if [[ -n "$found_file" && -f "$found_file" ]]; then
        echo "$found_file"
        return
    fi
    
    # If all strategies fail, return original path
    echo "$file_path"
}

# Main execution - capture just the visible pane for TypeScript errors
scrollback_content=$(tmux capture-pane -J -p)

# Parser functions for different error formats
parse_typescript_errors() {
    local content="$1"
    local result=""
    
    # TypeScript format: filepath(line,col): error TS####: message
    local ts_errors=$(echo "$content" | grep -E "[a-zA-Z0-9_/.-]+\.(js|ts|tsx|jsx|py|java|go|rs|cpp|c|h|md|txt|json|yaml|yml|toml|css|scss|html|vue|php|rb|sh|lua|nix)\([0-9]+,[0-9]+\): error TS[0-9]+:")
    
    while IFS= read -r error_line; do
        if [[ -n "$error_line" ]]; then
            file_path=$(echo "$error_line" | sed -E 's/^([^(]+)\([0-9]+,[0-9]+\): error.*/\1/')
            line_num=$(echo "$error_line" | sed -E 's/^[^(]+\(([0-9]+),[0-9]+\): error.*/\1/')
            error_msg=$(echo "$error_line" | sed -E 's/.*: error TS[0-9]+: (.*)/\1/')
            
            result+="$error_msg|$file_path|$line_num"$'\n'
        fi
    done <<< "$ts_errors"
    
    echo "$result"
}

parse_eslint_errors() {
    local content="$1"
    local result=""
    local current_file=""
    
    # ESLint format: file path followed by indented line:col error messages
    while IFS= read -r line; do
        if [[ "$line" =~ ^/[^[:space:]]*\.(js|ts|tsx|jsx|py|java|go|rs|cpp|c|h|md|txt|json|yaml|yml|toml|css|scss|html|vue|php|rb|sh|lua|nix)$ ]]; then
            current_file="$line"
        elif [[ -n "$current_file" && "$line" =~ ^[[:space:]]+[0-9]+:[0-9]+[[:space:]]+error ]]; then
            line_num=$(echo "$line" | sed -E 's/^[[:space:]]*([0-9]+):[0-9]+[[:space:]]+error.*/\1/')
            error_msg=$(echo "$line" | sed -E 's/^[[:space:]]*[0-9]+:[0-9]+[[:space:]]+error[[:space:]]+//')
            
            result+="$error_msg|$current_file|$line_num"$'\n'
        fi
    done <<< "$content"
    
    echo "$result"
}

# Detect format and parse accordingly
files_with_lines=""

if echo "$scrollback_content" | grep -q "([0-9]\+,[0-9]\+): error TS[0-9]\+:"; then
    # TypeScript compiler errors
    files_with_lines=$(parse_typescript_errors "$scrollback_content")
elif echo "$scrollback_content" | grep -q "^  *[0-9]\+:[0-9]\+  \+error"; then
    # ESLint errors  
    files_with_lines=$(parse_eslint_errors "$scrollback_content")
fi

# Reverse order to match scrollback visual order
files_with_lines=$(echo "$files_with_lines" | tac)

if [[ -z "$files_with_lines" ]]; then
    echo "No files with line numbers found in scrollback"
    exit 0
fi

# Process files to resolve absolute paths
resolved_files=""
while IFS='|' read -r error_msg file_path line_num; do
    if [[ -n "$file_path" && -n "$line_num" ]]; then
        resolved_path=$(resolve_file_path "$file_path" "$scrollback_content")
        resolved_files+="$error_msg|$resolved_path|$line_num"$'\n'
    fi
done <<< "$files_with_lines"

# Remove trailing newline
resolved_files="${resolved_files%$'\n'}"

if [[ -z "$resolved_files" ]]; then
    echo "No valid files found after path resolution"
    exit 0
fi

# Use tmux popup with fzf and external preview script
# Have the popup directly call tmux_nvim
tmux display-popup -E -w 99% -h 99% "
    selected=\$(echo '$resolved_files' | fzf --preview='tmux_find_files_preview {}' --preview-window=down:60% --header='Files from scrollback â†’ nvim')
    if [[ -n \"\$selected\" ]]; then
        # Extract file and line number from selection (format: error_msg|file|line)
        file=\$(echo \"\$selected\" | cut -d'|' -f2)
        line=\$(echo \"\$selected\" | cut -d'|' -f3)
        
        # Clean the line number - remove any non-digit characters
        line=\$(echo \"\$line\" | sed 's/[^0-9]//g')
        
        # Verify file exists and line number is valid before opening
        if [[ -f \"\$file\" && \"\$line\" =~ ^[0-9]+\$ ]]; then
            tmux_nvim \"\$file\" \"\$line\"
        else
            echo \"Error: File not found or invalid line number\"
            echo \"File: \$file\"
            echo \"Line: \$line\"
            exit 1
        fi
    fi
"

