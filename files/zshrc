#!/usr/bin/env bash

# Source plugin submodules
source ~/.config/zsh/plugins/vim/vim.plugin.zsh
source ~/.config/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
source ~/.config/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
source ~/.config/zsh/plugins/powerlevel10k/powerlevel10k.zsh-theme
source ~/.config/zsh/plugins/powerlevel10k/config/p10k-robbyrussell.zsh
source ~/.config/zsh/.p10k.zsh

autoload -U compinit && compinit

# history setup
setopt APPEND_HISTORY
setopt SHARE_HISTORY
HISTFILE=$HOME/.zsh_history
SAVEHIST=1000
HISTSIZE=999
setopt HIST_EXPIRE_DUPS_FIRST
setopt EXTENDED_HISTORY

# Start typing + [Up-Arrow] - fuzzy find history forward
autoload -U up-line-or-beginning-search
zle -N up-line-or-beginning-search
bindkey '\e[A' up-line-or-beginning-search
# Start typing + [Down-Arrow] - fuzzy find history backward
autoload -U down-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey '\e[B' down-line-or-beginning-search

addToPathFront() {
  if [[ "$PATH" != *"$1"* ]]; then
    export PATH=$1:$PATH
  fi
}
addToPathFront $HOME/bin:/usr/local/bin
addToPathFront $HOME/.local/bin
addToPathFront $HOME/.yarn/bin
addToPathFront $HOME/.config/yarn/global/node_modules/.bin
addToPathFront $HOME/.cargo/bin
addToPathFront $HOME/go/bin

export VISUAL=nvim
export EDITOR="$VISUAL"

export CLICOLOR=1
export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'

bindkey -s '^ ' "^utmux_sessionizer.sh\n"
bindkey -s -M vicmd '^ ' "ddAtmux_sessionizer.sh\n"
bindkey -s ^f "^uvim_opener.sh\n"
bindkey -s -M vicmd ^f "ddAvim_opener.sh\n"
bindkey -s ^b "^ubtop\n"
bindkey -s -M vicmd ^b "ddAbtop\n"
bindkey -s ^v "^uvi\n"
bindkey -s -M vicmd ^v "ddAvi\n"
bindkey -s ^y "^uy\n"
bindkey -s -M vicmd ^y "ddAy\n"
bindkey -s ^g "^ulazygit\n"
bindkey -s -M vicmd ^g "ddAlazygit\n"

function y() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    builtin cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}
eval "$(zoxide init zsh)"

gwz() {
  top=$(git rev-parse --show-toplevel 2>/dev/null)
  git_dir=$(git rev-parse --git-dir 2>/dev/null) || {
    echo "Not in a git repo"
    return 1
  }

  is_bare=$(git config --get --bool core.bare || echo "false")

  if [ "$is_bare" = "true" ]; then
    top="$git_dir"
  fi

  # Just list and navigate to existing worktrees
  dir=$(
    git worktree list --porcelain |
      awk '/^worktree /{print $2}' |
      fzf --height 10 --reverse
  ) || return 1
  [ -n "$dir" ] && z "$dir"
}

gwc() {
  top=$(git rev-parse --show-toplevel 2>/dev/null)
  git_dir=$(git rev-parse --git-dir 2>/dev/null) || {
    echo "Not in a git repo"
    return 1
  }

  is_bare=$(git config --get --bool core.bare || echo "false")

  if [ "$is_bare" = "true" ]; then
    top="$git_dir"
  fi
  
  # If an argument is provided, create a new branch
  if [ $# -ne 0 ]; then
    branch="$1"
    if [ "$is_bare" = "true" ]; then
      workdir="$(dirname "$git_dir")/$branch"
    else
      workdir="$top/$branch"
    fi
    git worktree add -b "$branch" "$workdir" HEAD && cd "$workdir"
    return
  fi
  
  # Otherwise, list remote branches and check one out
  echo "Remote branches:"
  git fetch --prune
  branch=$(git branch -r |
    grep -v HEAD |
    sed 's|origin/||' |
    sort -u |
    fzf --height 10 --reverse |
    tr -d '[:space:]')
    
  if [ -n "$branch" ]; then
    remote="origin/$branch"
    if [ "$is_bare" = "true" ]; then
      workdir="$(dirname "$git_dir")/$branch"
    else
      workdir="$top/$branch"
    fi
    git fetch origin "$branch:$branch.new" || {
      echo " fetch failed (branch $branch not found on origin?)"
      return 1
    }
    git worktree add -b "$branch" "$workdir" "$remote" && cd "$workdir"
    git update-ref -d refs/heads/"$branch.new" 2>/dev/null
  fi
}

gwd() {
  top=$(git rev-parse --show-toplevel 2>/dev/null)
  git_dir=$(git rev-parse --git-dir 2>/dev/null) || {
    echo "Not in a git repo"
    return 1
  }
  
  # Get all worktrees with their branches
  worktree_info=$(git worktree list --porcelain)
  
  # Extract and format worktree paths and branches for selection
  formatted_worktrees=$(echo "$worktree_info" | 
    awk 'BEGIN {path=""; branch=""} 
    /^worktree / {path=substr($0, 10)} 
    /^branch / {branch=substr($0, 8)} 
    branch != "" && path != "" {print path " [" branch "]"; path=""; branch=""}')
  
  # Let user select a worktree to delete
  selected=$(echo "$formatted_worktrees" | fzf --height 10 --reverse) || return 1
  
  # Extract path and branch from selection
  selected_path=$(echo "$selected" | awk '{print $1}')
  selected_branch=$(echo "$selected" | sed -E 's/.*\[(.*)\].*/\1/' | sed 's/refs\/heads\///')
  
  # Confirm deletion
  echo "Going to remove worktree at $selected_path"
  echo "and delete branch $selected_branch"
  read -q "REPLY?Are you sure? (y/n) "
  echo
  
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    current_dir=$PWD
    
    # Make sure we're not in the worktree we're trying to delete
    if [[ "$current_dir" == "$selected_path"* ]]; then
      echo "Cannot delete the worktree you're currently in. Moving to the main worktree..."
      cd $(git worktree list | head -1 | awk '{print $1}')
    fi
    
    # Remove the worktree and delete the branch
    git worktree remove --force "$selected_path" && 
    git branch -D "$selected_branch" &&
    echo "Worktree and branch deleted successfully."
  else
    echo "Operation cancelled."
  fi
}

if [ -f ~/.zshrc.local ]; then
  source ~/.zshrc.local
fi
