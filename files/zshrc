#!/usr/bin/env bash

# Source plugin submodules
source ~/.config/zsh/plugins/vim/vim.plugin.zsh
source ~/.config/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
source ~/.config/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
source ~/.config/zsh/plugins/powerlevel10k/powerlevel10k.zsh-theme
source ~/.config/zsh/plugins/powerlevel10k/config/p10k-robbyrussell.zsh
source ~/.config/zsh/.p10k.zsh

autoload -U compinit && compinit

# history setup
setopt APPEND_HISTORY
setopt SHARE_HISTORY
HISTFILE=$HOME/.zsh_history
SAVEHIST=1000
HISTSIZE=999
setopt HIST_EXPIRE_DUPS_FIRST
setopt EXTENDED_HISTORY

# Start typing + [Up-Arrow] - fuzzy find history forward
autoload -U up-line-or-beginning-search
zle -N up-line-or-beginning-search
bindkey '\e[A' up-line-or-beginning-search
# Start typing + [Down-Arrow] - fuzzy find history backward
autoload -U down-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey '\e[B' down-line-or-beginning-search

addToPathFront() {
  if [[ "$PATH" != *"$1"* ]]; then
    export PATH=$1:$PATH
  fi
}
addToPathFront $HOME/bin:/usr/local/bin
addToPathFront $HOME/.local/bin
addToPathFront $HOME/.yarn/bin
addToPathFront $HOME/.config/yarn/global/node_modules/.bin
addToPathFront $HOME/.cargo/bin
addToPathFront $HOME/go/bin

export VISUAL=nvim
export EDITOR="$VISUAL"

export CLICOLOR=1
export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'

bindkey -s '^ ' "^utmux_sessionizer.sh\n"
bindkey -s -M vicmd '^ ' "ddAtmux_sessionizer.sh\n"
bindkey -s ^f "^uvim_opener.sh\n"
bindkey -s -M vicmd ^f "ddAvim_opener.sh\n"
bindkey -s ^i "^uinit_project.sh\n"
bindkey -s -M vicmd ^i "ddAinit_project.sh\n"
bindkey -s ^b "^ubtop\n"
bindkey -s -M vicmd ^b "ddAbtop\n"
bindkey -s ^v "^uvi\n"
bindkey -s -M vicmd ^v "ddAvi\n"
bindkey -s ^y "^uy\n"
bindkey -s -M vicmd ^y "ddAy\n"
bindkey -s ^g "^ulazygit\n"
bindkey -s -M vicmd ^g "ddAlazygit\n"

function y() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    builtin cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}
eval "$(zoxide init zsh)"

gwz() {
  top=$(git rev-parse --show-toplevel 2>/dev/null)
  git_dir=$(git rev-parse --git-common-dir 2>/dev/null) || {
    echo "Not in a git repo"
    return 1
  }

  is_bare=$(git config --get --bool core.bare || echo "false")

  if [ "$is_bare" = "true" ]; then
    top="$git_dir"
  fi

  # Just list and navigate to existing worktrees
  dir=$(
    git worktree list --porcelain |
      awk '/^worktree /{print $2}' |
      fzf --height 10 --reverse
  ) || return 1
  
  if [ -n "$dir" ]; then
    # Save current directory
    current_dir="$PWD"
    
    # Get repo name from directory
    repo_name=$(basename "$(dirname "$dir")")
    
    # Get branch name from directory or git without changing our current directory
    # by using a subshell
    branch_name=$(
      (cd "$dir" 2>/dev/null && git branch --show-current | tr '/' '-')
    )
    session_name="${repo_name}_${branch_name}"
    
    # Check if already in a tmux session
    if [ -z "$TMUX" ]; then
      # Not in a tmux session, create or attach to one
      if tmux has-session -t "$session_name" 2>/dev/null; then
        tmux attach-session -t "$session_name"
      else
        tmux new-session -s "$session_name" -c "$dir"
      fi
    else
      # Already in a tmux session, switch to the session directly
      if tmux has-session -t "$session_name" 2>/dev/null; then
        tmux switch-client -t "$session_name"
      else
        tmux new-session -d -s "$session_name" -c "$dir"
        tmux switch-client -t "$session_name"
      fi
    fi
    
    # Stay in the original directory in the current session
    cd "$current_dir"
  fi
}

gwc() {
  top=$(git rev-parse --show-toplevel 2>/dev/null)
  git_dir=$(git rev-parse --git-common-dir 2>/dev/null) || {
    echo "Not in a git repo"
    return 1
  }

  is_bare=$(git config --get --bool core.bare || echo "false")

  if [ "$is_bare" = "true" ]; then
    top="$(realpath "$(dirname "$git_dir")")"
  fi

  if [ $# -ne 0 ]; then
    branch="$1"
    workdir="$top/$branch"
    if git worktree add -b "$branch" "$workdir" HEAD; then
      # Get repo name from directory
      repo_name=$(basename "$(dirname "$workdir")")
      # Format branch name
      session_name="${repo_name}_${branch}"
      
      # Check if already in a tmux session
      if [ -z "$TMUX" ]; then
        # Not in a tmux session, create or attach to one
        if tmux has-session -t "$session_name" 2>/dev/null; then
          tmux attach-session -t "$session_name"
        else
          tmux new-session -s "$session_name" -c "$workdir"
        fi
      else
        # Already in a tmux session, switch to the session directly
        if tmux has-session -t "$session_name" 2>/dev/null; then
          tmux switch-client -t "$session_name"
        else
          tmux new-session -d -s "$session_name" -c "$workdir"
          tmux switch-client -t "$session_name"
        fi
      fi
    fi
  else
    echo "Remote branches:"
    git fetch --prune
    branch=$(git branch -r |
      grep -v HEAD |
      sed 's|origin/||' |
      sort -u |
      fzf --height 10 --reverse |
      tr -d '[:space:]')

    if [ -n "$branch" ]; then
      remote="origin/$branch"
      workdir="$top/$branch"
      git fetch origin "$branch:$branch.new" || {
        echo " fetch failed (branch $branch not found on origin?)"
        return 1
      }
      if git worktree add -b "$branch" "$workdir" "$remote"; then
        git update-ref -d refs/heads/"$branch.new" 2>/dev/null
        
        # Get repo name from directory
        repo_name=$(basename "$(dirname "$workdir")")
        # Format branch name for session
        formatted_branch=$(echo "$branch" | tr '/' '-')
        session_name="${repo_name}_${formatted_branch}"
        
        # Check if already in a tmux session
        if [ -z "$TMUX" ]; then
          # Not in a tmux session, create or attach to one
          if tmux has-session -t "$session_name" 2>/dev/null; then
            tmux attach-session -t "$session_name"
          else
            tmux new-session -s "$session_name" -c "$workdir"
          fi
        else
          # Already in a tmux session, switch to the session directly
          if tmux has-session -t "$session_name" 2>/dev/null; then
            tmux switch-client -t "$session_name"
          else
            tmux new-session -d -s "$session_name" -c "$workdir"
            tmux switch-client -t "$session_name"
          fi
        fi
      fi
    fi
  fi

  if [ "$is_bare" = "true" ]; then
    if [ -d "$top/.claude" ]; then
      ln -sf "$top/.claude" "$workdir/.claude"
      echo "Created symlink for .claude directory"
    fi

    if [ -f "$top/CLAUDE.md" ]; then
      ln -sf "$top/CLAUDE.md" "$workdir/CLAUDE.md"
      echo "Created symlink for CLAUDE.md"
    fi
  fi
}

gwd() {
  top=$(git rev-parse --show-toplevel 2>/dev/null)
  git_dir=$(git rev-parse --git-dir 2>/dev/null) || {
    echo "Not in a git repo"
    return 1
  }

  # Get all worktrees with their branches
  worktree_info=$(git worktree list --porcelain)

  # Extract and format worktree paths and branches for selection
  formatted_worktrees=$(echo "$worktree_info" |
    awk 'BEGIN {path=""; branch=""} 
    /^worktree / {path=substr($0, 10)} 
    /^branch / {branch=substr($0, 8)} 
    branch != "" && path != "" {print path " [" branch "]"; path=""; branch=""}')

  # Let user select a worktree to delete
  selected=$(echo "$formatted_worktrees" | fzf --height 10 --reverse) || return 1

  # Extract path and branch from selection
  selected_path=$(echo "$selected" | awk '{print $1}')
  selected_branch=$(echo "$selected" | sed -E 's/.*\[(.*)\].*/\1/' | sed 's/refs\/heads\///')

  # Display which worktree and branch will be deleted
  echo "Removing worktree at $selected_path"
  echo "and deleting branch $selected_branch"

  current_dir=$PWD

  # Make sure we're not in the worktree we're trying to delete
  if [[ "$current_dir" == "$selected_path"* ]]; then
    echo "Cannot delete the worktree you're currently in. Moving to the main worktree..."
    cd $(git worktree list | grep '\[master\]' | awk '{print $1}')
  fi

  # Remove the worktree and delete the branch
  git worktree remove --force "$selected_path" &&
    git branch -D "$selected_branch" &&
    echo "Worktree and branch deleted successfully."
}

if [ -f ~/.zshrc.local ]; then
  source ~/.zshrc.local
fi
